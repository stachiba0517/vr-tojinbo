<!DOCTYPE html><html><head><meta charset="utf-8"><meta name="viewport" content="width=device-width"><link rel="icon" href="data:">
<title>VRæ±å°‹åŠã‚³ãƒ¼ã‚¹ã‚¿ãƒ¼ - VR-Tojinbo-Coaster</title>
<style>
body {
	margin: 0;
}
</style>
</head>
<body>
<!-- Import maps polyfill -->
<!-- Remove this when import maps will be widely supported -->
<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

<script type="importmap">
{
	"imports": {
		"three": "https://code4fukui.github.io/three.js/build/three.module.js",
		"three/addons/": "https://code4fukui.github.io/three.js/examples/jsm/"
	}
}
</script>

<script type="module">
import * as THREE from "three";
import { Curve, makeCurve, addCoaster } from "./TojinboCoaster.js";
import { VRButton } from "three/addons/webxr/VRButton.js";
import { WindNode } from "./WindNode.js";
import { setVBMode } from "./setVBMode.js";

const vbmode = location.hash == "#vbmode";

// wind audio
let context = null;
let audionode = null;

const stop = async () => {
  if (!context) return;
  await context.close();
  context = null;
	audionode = null;
};

const start = async () => {
  if (context) await stop();
  const sampleRate = 48000; // mac default
  context = new AudioContext({ sampleRate });

  const node = await WindNode.create(context);
  const fn = "./wind.wav";
  node.setWaveFile(fn);
  node.setOverwrap(0.058);
  node.connect(context.destination);
	audionode = node;
	
  //node.setVolume(range.value);
  //node.setPitch(range2.value);
};

//
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.xr.enabled = true;
renderer.xr.setReferenceSpaceType("local");
document.body.appendChild(renderer.domElement);
const btn = VRButton.createButton(renderer);
btn.addEventListener("click", () => {
	start();
});
document.body.onclick = () => {
	start();
};
document.body.appendChild(btn);
window.addEventListener("resize", () => {
	camera.aspect = window.innerWidth / window.innerHeight;
	camera.updateProjectionMatrix();
	renderer.setSize(window.innerWidth, window.innerHeight);
});

const scene = new THREE.Scene();

//const curve = makeCurve();
const curve = new Curve();
//await addCoaster(scene, curve, true);
await addCoaster(scene, curve);

if (vbmode) {
	setVBMode(scene);
}

const train = new THREE.Object3D();
scene.add(train);
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 500);
train.add(camera);

const position = new THREE.Vector3();
const tangent = new THREE.Vector3();
const lookAt = new THREE.Vector3();

let velocity = 0;
let progress = 0;
let prevProgress = 0;

let prevTime = performance.now();

renderer.setAnimationLoop(() => {
	const time = performance.now();
	const delta = time - prevTime;

	prevProgress = progress;
	progress += velocity;
	progress = progress % 1;

	position.copy(curve.getPointAt(progress));
	position.y += 0.6; // the eyes point height from the rail
	train.position.copy(position);
	tangent.copy(curve.getTangentAt(progress));

	velocity -= tangent.y * 0.0000008 * delta; // 8å€ï¼ˆ0.0000001 * 8ï¼‰
	const vmin = 0.00032; // 8å€ï¼ˆ0.00004 * 8ï¼‰
	const vmax = 0.0016; // 8å€ï¼ˆ0.0002 * 8ï¼‰
	velocity = Math.max(vmin, Math.min(vmax, velocity));
	train.lookAt(lookAt.copy(position).sub(tangent));

	// çœ‹æ¿ã®æ–‡å­—åˆ‡ã‚Šæ›¿ãˆï¼ˆã‚¹ã‚¿ãƒ¼ãƒˆ/ã‚´ãƒ¼ãƒ«ï¼‰
	if (scene.userData.signControl) {
		const signControl = scene.userData.signControl;
		
		// ä¸€å‘¨ã—ãŸã“ã¨ã‚’æ¤œå‡ºï¼ˆprogress ãŒ 1.0 ã‚’è¶…ãˆã¦ 0 ã«æˆ»ã£ãŸï¼‰
		const hasLooped = prevProgress > 0.8 && progress < 0.2;
		
		// ã‚´ãƒ¼ãƒ«ã‚¨ãƒªã‚¢ã«å…¥ã£ãŸã‚‰ã‚´ãƒ¼ãƒ«ã«åˆ‡ã‚Šæ›¿ãˆ
		if (progress >= 0.85 && !signControl.isGoal) {
			signControl.updateTexture(signControl.texture, 'ğŸ¦€ã‚´ãƒ¼ãƒ«ğŸ¦€');
			signControl.material.emissiveMap = signControl.texture;
			signControl.isGoal = true;
		} 
		// ä¸€å‘¨ã—ã¦ã‚¹ã‚¿ãƒ¼ãƒˆã‚¨ãƒªã‚¢ã‚’é€šéã—ãŸã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆã«æˆ»ã™
		else if (hasLooped && signControl.isGoal && progress > 0.4) {
			signControl.updateTexture(signControl.texture, 'ğŸ¦€ã‚¹ã‚¿ãƒ¼ãƒˆğŸ¦€');
			signControl.material.emissiveMap = signControl.texture;
			signControl.isGoal = false;
		}
	}

	// å¸ƒã®ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
	if (scene.userData.animatedMeshes) {
		scene.userData.animatedMeshes.forEach(mesh => {
			if (mesh.userData.isCloth) {
				mesh.userData.time += delta * 0.001;
				const t = mesh.userData.time;
				
				const geometry = mesh.geometry;
				const positions = geometry.attributes.position;
				const originalPositions = geometry.userData.originalPositions;
				
				// å„é ‚ç‚¹ã‚’æ³¢æ‰“ãŸã›ã‚‹ï¼ˆä¸‹åŠåˆ†ã®ã¿ï¼‰
				for (let i = 0; i < positions.count; i++) {
					const i3 = i * 3;
					const x = originalPositions[i3];
					const y = originalPositions[i3 + 1];
					
					// ä¸ŠåŠåˆ†ï¼ˆy > 0ï¼‰ã¯å›ºå®šã€ä¸‹åŠåˆ†ï¼ˆy <= 0ï¼‰ã®ã¿å‹•ã‹ã™
					if (y <= 0) {
						// yåº§æ¨™ã«å¿œã˜ã¦å‹•ãã®å¼·ã•ã‚’å¤‰ãˆã‚‹ï¼ˆä¸Šéƒ¨:0 â†’ ä¸‹éƒ¨:1ï¼‰
						const heightFactor = Math.abs(y / 5); // 0ã‹ã‚‰1ã®ç¯„å›²
						
						// é¢¨ã«ã‚ˆã‚‹æ³¢ã®åŠ¹æœ
						const wave1 = Math.sin(x * 0.3 + t * 2) * 0.4;
						const wave2 = Math.cos(y * 0.4 + t * 1.5) * 0.3;
						const wave3 = Math.sin(x * 0.2 + y * 0.3 + t * 2.5) * 0.5;
						
						// Zè»¸æ–¹å‘ã«æ³¢æ‰“ãŸã›ã‚‹ï¼ˆé«˜ã•ã«ã‚ˆã£ã¦å¼·åº¦ã‚’èª¿æ•´ï¼‰
						positions.setZ(i, (wave1 + wave2 + wave3) * heightFactor);
					} else {
						// ä¸ŠåŠåˆ†ã¯å…ƒã®ä½ç½®ã«å›ºå®šï¼ˆãƒã‚§ãƒ¼ãƒ³ã«æ¥ç¶šã•ã‚Œã¦ã„ã‚‹ï¼‰
						positions.setZ(i, originalPositions[i3 + 2]);
					}
				}
				
				positions.needsUpdate = true;
				geometry.computeVertexNormals();
			}
		});
	}

	renderer.render(scene, camera);
	prevTime = time;

	if (audionode) {
		const vp = (velocity - vmin) / (vmax - vmin);
		const pitch = 1 + vp;
		const vol = 0.3 + vp * .3;
		audionode.setPitchVolume(pitch, vol);
	}
});
</script>

</body>
</html>
